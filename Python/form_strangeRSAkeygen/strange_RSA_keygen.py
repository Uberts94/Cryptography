# Form exercise: https://docs.google.com/forms/d/e/1FAIpQLScgWM6NzHOhZ2YFFHywx7aPl5Tbcxd_s2YekakFR_KInvouog/viewform
# Followed: https://github.com/aldobas/cryptography-03lpyov-exercises/blob/master/AY2223/Python/attacks/RSA%20Attacks/3.common_prime.py

# from Crypto.Util.number import getPrime 
# from Crypto.Random.random import choice
# I need to generate 10 moduli, hence I generate 20 primes
# list =[]
# for i in range (20):
#     list.append(getPrime (1024))
# # now I multiply primes
# moduli = []
# for i in range (10) :
#     p1 = choice (list)
#     p2 = choice (list)
#     moduli.append ((p1*p2, p1, p2))

# One possible attack is the common prime one: since the modulus are generated by means the multiplication between 2 random primes,
# randomly chosen from a list, there could be modulus having common prime in the moduli list. 
# If the attacker is able to find the primes for some key, he can exactly reconstruct the RSA private key and decrypt the messages.

from data import *
from gmpy2 import gcd

keys = []
keys.append(k0);
keys.append(k1);
keys.append(k2);
keys.append(k3);
keys.append(k4);
keys.append(k5);
keys.append(k6);
keys.append(k7);
keys.append(k8);
keys.append(k9);
counter = 0
keyid = -1
otherkeyid = -1

for key in keys:
    keyid += 1
    for i in keys:
        otherkeyid += 1
        if keyid != otherkeyid:
            p = gcd(key[1], i[1])
            if p != 1:
                print("\n\n\nTesting k"+str(keyid)+" and k"+str(otherkeyid)+"....")
                #Common prime found
                print("Common prime found!")
                print(key[1] // p)
                print(i[1] // p)
                print("#########################################\n\n\n")
                counter += 1
    otherkeyid = 0
    

print("Prime number found: "+str(counter))